\chapter{Lexer and Parser}\label{ch:Lexer and Parser}

\newpage


% Structure Implementation for Context-Free Grammars
\section{Structure Implementation for Context-Free Grammars}\label{sec:Structure Implementation for Context-Free Grammars}

Before diving into language ambiguity testing and source code parsing, we need to properly read and accurately store the input grammar. A precise specification and understanding of the source grammar are fundamental for our parser’s architecture.\\

% Context-Free Grammar Definition
\begin{definition}[1.0]
    A context-free grammar is a 4-tuple \((N, T, P, S)\), where
    \begin{enumerate}
        \item \(N\) is a finite set called the nonterminal symbols,
        \item \(T\) is a finite set, disjoint from N, called the terminal symbols,
        \item \(P\) is a finite set of production rules, with each rule being a nonterminal deriving a string of terminal and/or nonterminal symbols,
        \item \(S \in N\) is the start nonterminal symbol.
    \end{enumerate}
\end{definition}
\setlength{\parindent}{0pt}

Given this definition of a context-free grammar, our implementation will replicate its structure to properly follow the mathematical theory used in this thesis.\\

For proper replication, we create these three classes:
\begin{enumerate}
    \item Class \(\boldsymbol{Symbol}\): \textit{Both terminal and nonterminal symbols are atomic elements of CFGs. Thus, we might want to create a class that will encapsulate these elements properly.}
    \item Class \(\boldsymbol{Production}\): \textit{In CFGs, production rules dictate how a nonterminal symbol can be replaced by a sequence of terminal and/or nonterminal symbols. Therefore, we need a class that will encapsulate the concept of a production rule.}
    \item Class \(\boldsymbol{Grammar}\): \textit{This class represents the entire CFG. \(\boldsymbol{Grammar}\) should replicate the mathematical definition of CFGs.}
\end{enumerate}

For a convenient implementation design, we group these three classes under a package named \(\boldsymbol{grammar}\).\\

Now let’s explore each of these classes in detail.

% Symbol Class
\subsection*{\(\boldsymbol{Symbol}\) Class}

The \(\boldsymbol{Symbol}\) class encapsulates the concept of terminal and nonterminal symbols. In CFGs, terminal and nonterminal symbols are strings. The input grammar explicitly determines which of the symbols are terminal and which are nonterminal.\\
Thus, to properly encapsulate the concept of a symbol of a CFG, we need an attribute for the string content and another attribute for the type of the symbol (terminal / nonterminal).\\

\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{content}\): \textit{A string representing the actual content of the symbol.}
    \item \(\boldsymbol{type}\): \textit{An enum indicating whether the symbol is a terminal or nonterminal.}
\end{itemize}

We also present some basic methods to further simplify and shorten the overall implementation of the parser.\\

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{constructor}\): \textit{Initializes a \(\boldsymbol{Symbol}\) object with the specified content and type.}
    \item \(\boldsymbol{isTerminal}\): \textit{Returns true if the symbol is terminal, returns false otherwise.}
    \item \(\boldsymbol{length}\): \textit{Returns the length of the content string.}
    \item \(\boldsymbol{equals}\): \textit{Determines whether two \(\boldsymbol{Symbol}\) objects are equal in both content and type.}
    \item \(\boldsymbol{hashCode}\): \textit{Returns a hash code of the symbol.}
\end{itemize}

\begin{codeblock}[Symbol Class]
    class Symbol {
        enum SymbolType {
            Terminal, Nonterminal
        }
        String content;
        SymbolType type;

        Symbol(String content, SymbolType type) {}
        boolean isTerminal() {}
        int length() {}
        boolean equals(Object obj) {}
        int hashCode() {}
    }
\end{codeblock}

\vspace{10pt}

% Production Class
\subsection*{\(\boldsymbol{Production}\) Class}

The \(\boldsymbol{Production}\) class encapsulates the concept of a production rule of a CFG. A representation of a production rule has the form:

\begin{verbatim}
left (nonterminal) → right (sequence of terminals and/or nonterminals)
\end{verbatim}

meaning – the right-hand side sequence can be derived from the left-hand side nonterminal. Therefore, to properly encapsulate a production rule we need two attributes: a left-hand side nonterminal and a right-hand side sequence of symbols.\\


\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{left}\): \textit{A nonterminal \(\boldsymbol{Symbol}\) representing the left-hand side of the production.}
    \item \(\boldsymbol{right}\): \textit{An Array List of \(\boldsymbol{Symbol}\) objects representing the sequence of terminals and/or nonterminals on the right side of the production.}
\end{itemize}

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{constructor}\): \textit{Initializes a \(\boldsymbol{Production}\) object with the specified left and right attributes.}
    \item \(\boldsymbol{equals}\): \textit{Determines if two \(\boldsymbol{Production}\) objects are equal in both left and right.}
    \item \(\boldsymbol{hashCode}\): \textit{Returns a hash code of the symbol.}
\end{itemize}

\begin{codeblock}[Production Class]
    class Production {
        Symbol left;
        List<Symbol> right;

        Production(Symbol left, List<Symbol> right) {}
        boolean equals(Object obj) {}
        int hashCode() {}
    }
\end{codeblock}

\vspace{10pt}

% Grammar Class
\subsection*{\(\boldsymbol{Grammar}\) Class}

The \(\boldsymbol{Grammar}\) class represents an entire context-free grammar. Therefore, it should properly encompass:

\begin{enumerate}
    \item The start nonterminal.
    \item The terminal symbols.
    \item The nonterminal symbols.
    \item The production rules.
\end{enumerate}

That’s why we create these 4 attributes for the \(\boldsymbol{Grammar}\) class:\\

\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{start}\): \textit{A nonterminal \(\boldsymbol{Symbol}\) object representing the start symbol of the grammar. By convention, it’s the left side of the first production rule of the CFG.}
    \item \(\boldsymbol{terminals}\): \textit{A set of \(\boldsymbol{Symbol}\) objects representing the terminal symbols of the grammar.}
    \item \(\boldsymbol{nonterminals}\): \textit{A set of \(\boldsymbol{Symbol}\) objects representing the nonterminal symbols of the grammar.}
    \item \(\boldsymbol{productions}\): \textit{A list of \(\boldsymbol{Production}\) objects representing the production rules of the grammar.}
\end{itemize}

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{constructor}\): \textit{Initializes a \(\boldsymbol{Grammar}\) object based on the provided file path parameters:}
    \begin{verbatim} Grammar.txt, Terminals.txt.\end{verbatim}
    \textit{In order to simplify the implementation of the \(\boldsymbol{constructor}\), in the next section we will introduce other methods inside the \(\boldsymbol{Grammar}\) class.}
\end{itemize}

\begin{codeblock}[Grammar Class]
    class Grammar {
        Symbol start;
        Set<Symbol> terminals;
        Set<Symbol> nonterminals;
        List<Production> productions;

        Grammar(String grammarFilePath, String terminalsFilePath) {}
        ...
    }
\end{codeblock}

\newpage


% Lexical Analysis and Tokenization
\section{Lexical Analysis and Tokenization}\label{sec:Lexical Analysis and Tokenization}

The preceding section of the thesis introduced an efficient structure for storing a CFG. This section explores the methods to accurately read and tokenize the input grammar within this structure.\\

We provide the input grammar by passing two file paths as parameters to the \(\boldsymbol{Grammar.constructor}\):
\begin{itemize}
    \item  \texttt{Grammar.txt}: \textit{Contains the entire CFG (C0 in our case. Exactly the same representation as in Table 1.0).}
    \item  \texttt{Terminals.txt}: \textit{Lists all terminal symbols. Notably, unlike nonterminal symbols, not all terminal symbols can be identified from \texttt{Grammar.txt} alone, Therefore, it’s essential to explicitly define all terminal symbols.}
\end{itemize}

The provided \texttt{.txt} files are essentially lines of strings lacking any inherent meaning. Tokenization transforms these lines of strings into sequences of \(\boldsymbol{Symbol}\) objects. We will demonstrate how to read from these \texttt{.txt} files, tokenize the content, and store it appropriately.

% readTerminals
\subsection*{\(\boldsymbol{Grammar.readTerminals}\)}

Parameters: \textit{String \(\boldsymbol{terminalFilePath}\).}

Throws: \textit{\(\boldsymbol{FileNotFoundException}\) if the \(\boldsymbol{terminalFilePath}\) is invalid.}

Returns: \textit{\(\boldsymbol{void}\).}\\

\textbf{Specification:} \textit{Utilizes \(\boldsymbol{terminalFilePath}\) to read \texttt{Terminals.txt} and stores all terminal symbols in \(\boldsymbol{Grammar.terminals}\).}\\

Each line in \texttt{Terminals.txt} represents a terminal symbol of the input grammar. The method reads the file line-by-line, removes all whitespace to prevent unexpected errors, creates the corresponding \(\boldsymbol{Symbol}\) objects, and stores them in \(\boldsymbol{Grammar.terminals}\).

Additionally, the method adds \(\boldsymbol{Symbol}\) objects for these characters \textit{" ", "\texttt{\textbackslash t}", "\texttt{\textbackslash n}"}.

\vspace{30pt}

% readNonerminals
\subsection*{\(\boldsymbol{Grammar.readNonterminals}\)}

Parameters: \textit{String \(\boldsymbol{grammarFilePath}\).}

Throws: \textit{\(\boldsymbol{FileNotFoundException}\) if the \(\boldsymbol{grammarFilePath}\) is invalid.}

Returns: \textit{\(\boldsymbol{void}\).}\\

\textbf{Specification:} \textit{Utilizes \(\boldsymbol{grammarFilePath}\) to read \texttt{Grammar.txt} and stores all nonterminal symbols in \(\boldsymbol{Grammar.nonterminals}\).}\\

Each line in \texttt{Grammar.txt} corresponds to a production rule of the input grammar. As by convention at some point, every nonterminal symbol is referenced on the left-hand side of a production rule. Recognizing all nonterminal symbols requires extracting the left-hand side symbols from all production rules and storing them in the set \(\boldsymbol{Grammar.nonterminals}\).

To do this, the method reads the file line-by-line, removes all whitespace to prevent errors, splits each line at the \texttt{→} symbol, crates \(\boldsymbol{Symbol}\) object from the left-hand side of the \texttt{→}, and stores it in \(\boldsymbol{Grammar.nonterminals}\).

\vspace{30pt}

% readProductions
\subsection*{\(\boldsymbol{Grammar.readProductions}\)}

Parameters: \textit{String \(\boldsymbol{grammarFilePath}\).}

Throws: \textit{\(\boldsymbol{FileNotFoundException}\) if the \(\boldsymbol{grammarFilePath}\) is invalid.}

Returns: \textit{\(\boldsymbol{void}\).}\\

\textbf{Specification:} \textit{Utilizes \(\boldsymbol{grammarFilePath}\) to read \texttt{Grammar.txt} and save all production rules in \(\boldsymbol{Grammar.productions}\).}\\

As mentioned earlier, each line in \texttt{Grammar.txt} represents a production rule of the grammar. Sometimes, the symbol \texttt{|} is used to represent multiple productions on the same line when the left-hand side nonterminal is identical for these productions.\\

Example: \texttt{S → a | b}

For proper implementation, we should decompose such representations and store each production separately.\\

Instead of,  \texttt{S → a | b}, we should store,  \texttt{S → a; S → b}, separately.\\

To do so, we split each string line by  \texttt{→}. Then we create a variable, \(left\), which is a \(\boldsymbol{Symbol}\) object obtained from the left-hand side string. We save the right-hand side string as  \(rightString\). To decompose  \(rightString\), we split it by \texttt{|} and store the resulting parts in a string array called \(rightParts\). Each element in \(rightParts\) is a string representing a sequence of symbols derivable from the \(left\) nonterminal. The next essential step is to tokenize the elements of \(rightParts\).\\

A right-hand side string of the production rule consists of a sequence of symbols, and our task is to correctly identify each one. We introduce the \(\boldsymbol{stringIntoSymbols}\) method to tokenize these strings. The methods’s complete specification is provided below.\\

We iterate through the \(rightParts\) array. Using \(\boldsymbol{stringIntoSymbols}\), we store the tokenization result – a list of \(\boldsymbol{Symbol}\) objects in a local variable \(right\). During this process, given that we have both \(left\) and \(right\), we form a ‘\(\boldsymbol{Production}\) object and save it in \(\boldsymbol{Grammar.productions}\). This approach allows us to store each production separately, breaking down the initial representation of the production rule.

\vspace{30pt}

% stringIntoSymbols
\subsection*{Static \(\boldsymbol{stringIntoSymbols}\)}

Parameters: \textit{String \(\boldsymbol{str}\), Set\texttt{<}Symbol\texttt{>} \(\boldsymbol{terminals}\), Set\texttt{<}Symbol\texttt{>} \(\boldsymbol{nonterminals}\).}

Returns: \textit{ List\texttt{<}Symbol\texttt{>} \(\boldsymbol{stringIntoSymbolsArray}\).}\\

\textbf{Specification:} \textit{The method takes in a string of symbols and sets of both terminal and nonterminal symbols. It breaks down the provided string into individual symbols and returns a list of corresponding \(\boldsymbol{Symbol}\) objects. To accurately identify every symbol in the string, we must be aware of the symbols present in the grammar, hence the need for terminal and nonterminal sets as parameters.}\\

The tokenization process proceeds as follows:

We start from the beginning of the string \(\boldsymbol{str}\) and recognize the longest symbol available one by one.\\

For instance, tokenizing the string \(\boldsymbol{str}\) = \texttt{"int main()\{return 0\}\( \dashv \)"} results in the following steps:

\begin{enumerate}
    \item \(\boldsymbol{resultArray}\) = \texttt{[]}; \hfill \(\boldsymbol{str}\) = \texttt{"int main()\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int]}; \hfill \(\boldsymbol{str}\) = \texttt{" main()\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  ,]}; \hfill \(\boldsymbol{str}\) = \texttt{"main()\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main]}; \hfill \(\boldsymbol{str}\) = \texttt{"()\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (]}; \hfill \(\boldsymbol{str}\) = \texttt{")\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, )]}; \hfill \(\boldsymbol{str}\) = \texttt{"\{return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{]}; \hfill \(\boldsymbol{str}\) = \texttt{"return 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{, return]}; \hfill \(\boldsymbol{str}\) = \texttt{" 0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{, return,  ]}; \hfill \(\boldsymbol{str}\) = \texttt{"0\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{, return,  , 0]}; \hfill \(\boldsymbol{str}\) = \texttt{"\}\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{, return,  , 0, \}]}; \hfill \(\boldsymbol{str}\) = \texttt{"\( \dashv \)"}
    \item \(\boldsymbol{resultArray}\) = \texttt{[int,  , main, (, ), \{, return,  , 0, \}, \( \dashv \)]}; \hfill \(\boldsymbol{str}\) = \texttt{""}
\end{enumerate}

The Symbol \( \dashv \) represents the \(\boldsymbol{endmark}\) symbol, introduced in Michael Sipser's book.

\newpage


% Structure Implementation of DK1 Automaton
\section{Structure Implementation of \(\boldsymbol{DK_{1}}\) Automaton}\label{sec:Structure Implementation of DK1 Automaton}

Since we already possess the input grammar, we can now test whether that grammar is LR(1) or not. The book "Introduction to the Theory of Computation" suggests constructing a \( DK_{1} \) automaton for this purpose. Before constructing the \( DK_{1} \) automaton for a specific CFG, we must implement its general structure as mathematically outlined in the book. This section will discuss the \( DK_{1} \) automaton’s structure implementation, while the next section will cover its construction process for a specific language, in our case the C0 language.

\vspace{20pt}

% DK1 automaton structure
\subsection*{\(\boldsymbol{DK_{1}}\) automaton structure}

% ----- Image: Example of DK_1 automaton

A \( DK_{1} \) is a finite deterministic automaton.

% Finite deterministic automaton Definition
\begin{definition}[2.0]
    A finite deterministic automaton (DFA) is defined as a 5-tuple  \((Q, \Sigma, \delta, q_{0}, F)\), where
    \begin{enumerate}
        \item \(Q\) is a finite set called the states,
        \item \(\Sigma\) is a finite set called the alphabet,
        \item \(\delta : Q \times \Sigma \to Q\) is the transition function,
        \item \(q_{0} \in Q\) is the start state, and
        \item \(F\) is the set of accept states.
    \end{enumerate}
\end{definition}
\setlength{\parindent}{0pt}

In \( DK_{1} \) automaton, a state encapsulates \(items\) (also referred to as \(dotted rules\)). Each \(item\) contains a production rule, a dot at the corresponding point in the rule to signify progress, and lookahead symbols. If this terminology is unfamiliar to you, please refer to the book "Introduction to the Theory of Computation”.\\

Based on the \( DK_{1} \) automaton specification from "Introduction to the Theory of Computation”, and the definition of finite deterministic automaton we aim to replicate the \( DK_{1} \) automaton's structure to align our implementation with the mathematical theory developed by Michael Sipser.

We create the following three classes:
\begin{enumerate}
    \item Class \(\boldsymbol{Item}\): \textit{The Items (dotted rules) serve as fundamental elements of the states in \( DK_{1} \). Therefore, we need a class to encapsulate this concept.}
    \item Class \(\boldsymbol{State}\): \textit{The need for a \(\boldsymbol{State}\) class is evident. An automaton consists of states, and each state encompasses several \(\boldsymbol{State}\) objects.}
    \item Class \(\boldsymbol{DK_{1}}\): \textit{This class represents the entire \( DK_{1} \) automaton.}
\end{enumerate}

These classes will be grouped under a package named \(\boldsymbol{dk1}\).\\

Let’s delve into the details of each of these classes.

% Item Class
\subsection*{\(\boldsymbol{Item}\) Class}

The \(\boldsymbol{Item}\) class encapsulates the concept of an item (dotted rule) as presented in the book. It comprises a production rule, the location of a dot within this production rule, and lookahead symbols. To efficiently represent this concept, we will utilize three attributes along with several straightforward methods.\\

\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{production}\): \textit{A \(\boldsymbol{Production}\) object that represents the production rule for this item.}
    \item \(\boldsymbol{dotIndex}\): \textit{An Integer that represents the location of the corresponding dot in the item}
    \item \(\boldsymbol{lookaheads}\): \textit{A set of \(\boldsymbol{Symbol}\) objects to represent all the lookahead symbols for this item}
\end{itemize}

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{constructor}\): \textit{Initializes an \(\boldsymbol{Item}\) object with the specified production, dotIndex, and lookaheads.}
    \item \(\boldsymbol{isComplete}\): \textit{Returns true if the \(item\) is complete, i.e., if the dot is at the end of the production rule; otherwise, it returns false.}
    \item \(\boldsymbol{currentSymbol}\): \textit{Returns the symbol next to the dot in the production rule if it exists; Otherwise returns \(null\).}
    \item \(\boldsymbol{nextSymbol}\): \textit{Returns the symbol after the symbol next to the dot in the production rule if it exists, Otherwise returns \(null\). These methods, are trivial but shorten the whole implementation code significantly.}
    \item \(\boldsymbol{equals}\): \textit{Determines if two \(\boldsymbol{Item}\) objects are equal in all attributes: production, dotIndex, and lookaheads.}
    \item \(\boldsymbol{hashCode}\): \textit{Returns a hash code of the item.}
    \item \(\boldsymbol{sameProductionAndDot}\): \textit{This method is similar to \(\boldsymbol{equals}\), but it doesn't compare lookaheads. During the lookahead calculation, it's essential to identify identical production rules and dotIndex for grouping the lookaheads.}
    \item \(\boldsymbol{addLookaheads}\): \textit{Merges two sets of lookahead symbols}
\end{itemize}

\begin{codeblock}[Item Class]
    class Item {
        Production production;
        int dotIndex;
        Set<Symbol> lookaheads;

        Item(Production production, int dotIndex, Set<Symbol> lookaheads) {}
        boolean isComplete() {}
        Symbol currentSymbol() {}
        Symbol nextSymbol(){}
        boolean equals(Object obj) {}
        int hashCode() {}
        boolean sameProductionAndDot(Item item) {}
        void addLookaheads(Set<Symbol> newLookaheads) {}
    }
\end{codeblock}

\vspace{10pt}

% State Class
\subsection*{\(\boldsymbol{State}\) Class}

The \(\boldsymbol{State}\) class represents a state within the \(DK_{1}\) automaton. It comprises a set of \(\boldsymbol{Item}\) objects, a local transition function specific to this state, and a set of complete rules, which are \(\boldsymbol{Item}\) objects with a dot at the end of the production rule.\\

\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{items}\): \textit{A set of \(\boldsymbol{Item}\) objects that represents all the items for this state}
    \item \(\boldsymbol{transitionFunction}\): \textit{A Map\(<\)Symbol, State\(>\) representing the neighboring states of the current state. In other words, the \(\boldsymbol{transitionFunction}\) tracks paths from the current state to other states via a specific \(\boldsymbol{Symbol}\) object.}
    \item \(\boldsymbol{completeItems}\): \textit{A set of \(\boldsymbol{Item}\) objects to represent all the complete rules.}
\end{itemize}

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{addItem}\): \textit{adds a new \(\boldsymbol{Item}\) object to the items. If a similar item with the same production and dotIndex already exists, the method simply merges the lookaheads and returns false.}
    \item \(\boldsymbol{sameItems}\): \textit{Returns true if two \(\boldsymbol{State}\) objects possess identical sets of \(\boldsymbol{Item}\) objects. Although two states may be identical, they might not be considered equal if one is still under construction and its \(\boldsymbol{transitionFunction}\) isn’t finalized. Therefore, identity is checked using the items.}
    \item \(\boldsymbol{createTransitionState}\): \textit{Creates and returns a new \(\boldsymbol{State}\) object with a given set of items. If the state with the same items already exists, the method doesn’t create a new state and returns an existing one. Creating new transition states is necessary in the construction process of the automaton.}
\end{itemize}

\begin{codeblock}[State Class]
    class State {
        Set<Item> items;
        Map<Symbol, State> transitionFunction;
        Set<Item> completeItems;

        boolean addItem(Item newItem) {}
        boolean sameItems(State newState) {}
        State createTransitionState(Set<Item> transitionItems, Set<State> states, Grammar g) {}
    }
\end{codeblock}

\vspace{10pt}

% DK1 Class
\subsection*{\(\boldsymbol{DK1}\) Class}

The \(\boldsymbol{DK1}\) class represents the concept of the entire \(\boldsymbol{DK_{1}}\) deterministic finite automaton. Thus, it should encompass all the tuple elements mentioned in the definition of the DFA.\\

\textbf{Attributes:}
\begin{itemize}
    \item \(\boldsymbol{start}\): \textit{A \(\boldsymbol{start}\) object representing the start state of the automaton.}
    \item \(\boldsymbol{states}\): \textit{A set of \(\boldsymbol{start}\) objects representing all the states of the automaton.}
    \item \(\boldsymbol{grammar}\): \textit{A \(\boldsymbol{Grammar}\) object representing the input CFG.}
\end{itemize}

Let's ensure these three attributes encompass all elements of the DFA's 5-tuple.

\begin{enumerate}
    \item States (\(\boldsymbol{Q}\)):  \textit{\(\boldsymbol{DK1.states}\).}
    \item Alphabet (\(\boldsymbol{\Sigma}\)):  \textit{\(\boldsymbol{DK1.grammar.terminals}\) \(\cup\) \(\boldsymbol{DK1.grammar.nonterminals}\).}
    \item Transition Function (\(\boldsymbol{\delta}\)):  \textit{Since each \(\boldsymbol{State}\) object possesses its own local \(\boldsymbol{transitionFunction}\), \(\boldsymbol{\delta}\) is represented through \(\boldsymbol{DK1.states}\).}
    \item Start state (\(\boldsymbol{q_{0}}\)):  \textit{\(\boldsymbol{DK1.start}\).}
    \item Set of accept states (\(\boldsymbol{F}\)):  \textit{Following the literature, a state is considered accepting if it contains a completed rule, specifically, an item with a dot at the end. Consequently, we can identify accepting states by iterating through the items of a \(\boldsymbol{State}\) and using the \(\boldsymbol{Item.isComplete()}\) method. \(\boldsymbol{DK1.states}\).}
\end{enumerate}

All the methods mentioned below are quite complex from the implementation point of view. Here, we'll provide a brief description and reserve a detailed specification for the subsequent sections.\\

\textbf{Methods:}
\begin{itemize}
    \item \(\boldsymbol{constructor}\): \textit{Constructs an entire \(DK_{1}\) automaton based on the provided input \(\boldsymbol{Grammar}\) object.}
    \item \(\boldsymbol{dk1Test}\): \textit{Returns true if the \(\boldsymbol{Grammar}\) is LR(1), false otherwise.}
    \item \(\boldsymbol{parseString}\): \textit{Returns a derivation tree for the given \textbf{valid string}.}
    \item \(\boldsymbol{findHandle}\): \textit{Returns the handle for the given \textbf{valid string}.}
    \item \(\boldsymbol{makeReduction}\): \textit{Makes a one-step reduction of the \textbf{valid string} based on the provided handle.}
\end{itemize}

\begin{codeblock}[DK1 Class]
    class DK1 {
        State start;
        Set<State> states;
        Grammar g;

        DK1(Grammar grammar) {}
        boolean dk1Test() {}
        DTE parseString(String validString) {}
        Item findHandle(List<Symbol> validStringArray) {}
        List<Symbol> makeReduction(List<Symbol> validStringArray, Item handle) {}
    }
\end{codeblock}

\newpage


% DK1 Automaton Builder for a CFG
\section{\(\boldsymbol{DK_{1}}\) Automaton Builder for a CFG}\label{sec:DK1 Automaton Builder for a CFG}

We have built a solid framework to construct the \(DK_{1}\) automaton of a particular CFG. \(DK_{1}\) is a deterministic finite automaton that will help us to test the input grammar and then parse the source code. The implementation will closely follow the theory developed in the "Introduction to the Theory of Computation". Note that the implementation process is intricate. For instance, while the example of the \(DK_{1}\) automaton for a basic grammar in Table 2.0 has only 9 states with a few items, the \(DK_{1}\) of the C0 grammar comprises 3264 states with a vast number of items. Even a small error in the implementation can drastically alter the automaton.

\vspace{10pt}

% DK1.constructor
\subsection*{\(\boldsymbol{DK1.constructor}\)}

Parameters: \textit{Grammar \(\boldsymbol{grammar}\).}

Returns: \textit{\(\boldsymbol{DK1}\).}\\

\textbf{Specification:} \textit{Creates the \(DK_{1}\) automaton for the given CFG.}\\

The constructor method of the \(DK_{1}\) class creates the entire automaton. As previously emphasized, this is a delicate process. We will thus utilize several auxiliary methods to break down the intricate procedure into more manageable tasks. Below is the formal specification of \(DK_{1}\) building process from the book:\\

% formal building process from Sipser's book.

\vspace{15pt}

% Start State Creation
\textbf{\textit{Start State Creation}}\\

Firstly, we need to initialize \(\boldsymbol{DK1.start}\), which encompasses all items where the left-hand attribute of the production is equal to \(\boldsymbol{Grammar.start}\). Additionally, \(\boldsymbol{DK1.lookaheads}\) should be set to \(\boldsymbol{Grammar.terminals}\), and \(\boldsymbol{DK1.dotIndex}\) should be assigned to the value 0.\\

Whenever a new state is created, it must be updated with \(\varepsilon\)-transitions as previously described. However, this updating process can be recursive. To address this, we introduce a specialized method \(\boldsymbol{makeEpsilonMoves}\). This method is responsible for updating the current state with \(\varepsilon\)-transitions until no further \(\varepsilon\)-transitions are possible for this state. The implementation details of this method are discussed in the next subsection.\\

\vspace{15pt}

% Make a Queue
\textbf{\textit{Make a Queue}}\\

Next, we create a queue structure, referred to as \(queue\), composed of \(\boldsymbol{State}\) objects. We use breadth-first search (BFS) to produce new neighboring states and to construct the entire automaton. The queue's first element is predictably \(\boldsymbol{DK1.start}\).\\

\vspace{15pt}

% Process the Queue
\textbf{\textit{Process the Queue}}\\

During each iteration, we extract and eliminate the first \(\boldsymbol{State}\) element from the queue, referred to as \(\boldsymbol{currentState}\). To generate new neighboring states, we must execute shift transitions as defined above. A separate function, \(\boldsymbol{makeShiftMoves}\), is defined to update the \(\boldsymbol{currentState}\) considering shift transitions. This method fills \(\boldsymbol{currentState.transitionFunction}\) completely with the appropriate transition paths.\\

To update the queue, we loop through \(\boldsymbol{currentState.transitionFunction}\), appending its neighboring states to the queue. However, to avoid infinite loops, we must never add a state to the queue more than once. We maintain a list of previously visited states, \(\boldsymbol{queueCheck}\), and use \(\boldsymbol{State.sameItems}\) to determine whether a state has been visited. If a neighbor state hasn't been visited, it will be added to the queue.\\

The end of this loop will complete the \(DK_{1}\) automaton building process. Now, let's detail the functions we used above: \(\boldsymbol{makeEpsilonMoves}\) and \(\boldsymbol{makeShiftMoves}\).

\vspace{30pt}

% makeEpsilonMoves
\subsection*{\(\boldsymbol{makeEpsilonMoves}\)}

Parameters: \textit{Grammar \(\boldsymbol{grammar}\).}

Returns: \textit{\(\boldsymbol{void}\).}\\

\textbf{Specification:} \textit{Implements the \(\varepsilon\)-transitions making process as described in the book.}\\

In simpler terms, if a state has an item with the dot following a nonterminal symbol, we must include all new items in the state, with this nonterminal as the left attribute of the production, dotIndex set to 0, and lookaheads updated as previously specified. The \(\boldsymbol{grammar}\) parameter grants access to terminals, nonterminals, and productions.\\

Notably, this is a recursive operation. We use a while loop that continues as long as new items are added to the state. Within this loop, we cycle through items, attempting to introduce new items. The currently iterated item is labeled  \(\boldsymbol{currentItem}\). If the dot of \(\boldsymbol{currentItem}\) follows a nonterminal, we add a new item with the left set to this nonterminal, dotIndex to 0, and lookaheads are updated according to the book's specification. A function, \(\boldsymbol{lookaheadsFromSymbol}\), returns an updated set of lookahead symbols. Then, we iterate through all the \(\boldsymbol{Grammar.productions}\), selecting all productions with this nonterminal on the left, and creating a new item with the corresponding attributes. If a new item is added to the state during this iteration, the process repeats.\\

\begin{codeblock}[makeEpsilonMoves pseudocode]
    FUNCTION makeEpsilonMoves(Grammar g)
    DECLARE newItems as boolean

    DO
    SET newItems to false

    // Create a copy of items to avoid ConcurrentModificationException
    FOR EACH currentItem IN a NEW HashSet COPIED FROM items
    DECLARE currentSymbol as Symbol, SET to currentItem.currentSymbol()

    // Continue if the current symbol is null
    IF currentSymbol IS NULL THEN
    CONTINUE
    END IF

    // Process if the current symbol is non-terminal
    IF currentSymbol is NOT a terminal THEN
    DECLARE nextSymbol as Symbol, SET to currentItem.nextSymbol()
    DECLARE lookaheads as NEW HashSet of Symbol

    // Determine lookaheads
    IF nextSymbol IS NULL THEN
    COPY lookaheads from currentItem.getLookaheads()
    ELSE
    SET lookaheads to State.lookaheadsFromSymbol(nextSymbol, NEW HashSet, g)
    END IF

    // Iterate through productions in grammar
    FOR EACH production IN g.getProductions()
    // Check if the left side of the production equals the current symbol
    IF production.getLeft() EQUALS currentSymbol THEN
    CREATE newItem as new Item with (production, 0, lookaheads)
    UPDATE newItems with OR of newItems and addItem(newItem) result
    END IF
    END FOR
    END IF
    END FOR
    WHILE newItems IS TRUE

    END FUNCTION
\end{codeblock}

\vspace{30pt}

% lookaheadsFromSymbol
\subsection*{\(\boldsymbol{lookaheadsFromSymbol}\)}

Parameters: \textit{Symbol \(\boldsymbol{symbol}\), Set\(<\)Symbol\(>\) \(\boldsymbol{symbols}\), Grammar \(\boldsymbol{grammar}\).}

Returns: \textit{Set\(<\)Symbol\(>\) \(\boldsymbol{lookaheadsFromSymbol}\) .}\\

\textbf{Specification:} \textit{Calculates and returns all the terminal symbols that can be the first symbol of the valid strings, derivable from the given \(\boldsymbol{symbol}\) within this \(\boldsymbol{grammar}\). As this function is also recursive, the \(\boldsymbol{symbols}\) parameter keeps track of visited symbols to avoid infinite loops.}\\

\begin{codeblock}[lookaheadsFromSymbol pseudocode]
    FUNCTION lookaheadsFromSymbol(Symbol symbol, HashSet of Symbol symbols, Grammar g)
    DECLARE lookaheads as a NEW HashSet of Symbol
    ADD symbol to symbols

    // If the symbol is terminal, return a set containing only this symbol
    IF symbol is a terminal THEN
    ADD symbol to lookaheads
    RETURN lookaheads
    ELSE
    // Iterate through productions in the grammar
    FOR EACH production IN g.getProductions()
    // Check if the left side of the production equals the symbol
    IF production.getLeft() EQUALS symbol THEN
    DECLARE derivedSymbol as Symbol, SET to the first symbol of production's right side

    // Recursively compute lookaheads if derivedSymbol has not been visited
    IF NOT symbols CONTAINS derivedSymbol THEN
    UNION lookaheads with lookaheadsFromSymbol(derivedSymbol, symbols, g)
    END IF
    END IF
    END FOR
    END IF

    RETURN lookaheads
    END FUNCTION

\end{codeblock}

\vspace{30pt}

% makeShiftMoves
\subsection*{\(\boldsymbol{makeShiftMoves}\)}

Parameters: \textit{Set\(<\)State\(>\) \(\boldsymbol{states}\), Grammar \(\boldsymbol{grammar}\).}

Returns: \textit{\(\boldsymbol{void}\).}\\

\textbf{Specification:} \textit{Implements the shift transitions making process specified in the book. This method initializes new states, when necessary. The \(\boldsymbol{states}\) parameter ensures not to create the same state multiple times.}\\

The core task of this function is advancing the dot by one symbol to the right. This action triggers new paths/transitions for the automaton. However, the neighboring state might not have been established. Hence, we determine new pathways and, if the requisite state is absent, employ the \(\boldsymbol{State.createTransitionState(...)}\) method to initialize the neighbor.//

\begin{codeblock}[makeShiftMoves pseudocode]
    FUNCTION makeShiftMoves(HashSet of State states, Grammar g)
    DECLARE symbolToItemsMap as a NEW HashMap from Symbol to Set of Item

    // Find all transition symbol possibilities and map their items
    FOR EACH item IN items
    DECLARE currentSymbol as Symbol, SET to item.currentSymbol()

    // Continue if the current symbol is null
    IF currentSymbol IS NULL THEN
    CONTINUE
    END IF

    // Map the symbol to its corresponding items
    ADD item to symbolToItemsMap under currentSymbol
    END FOR

    // Make transition paths
    FOR EACH entry IN symbolToItemsMap.entrySet()
    DECLARE transitionSymbol as Symbol, SET to entry's key
    DECLARE transitionItems as Set of Item, SET to entry's value

    // Create transition state
    DECLARE transitionState as State, SET to createTransitionState with transitionItems, states, and g
    MAP transitionSymbol to transitionState in transitionFunction
    END FOR
    END FUNCTION


\end{codeblock}